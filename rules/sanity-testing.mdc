---
description: Best practices for testing Sanity Studio customizations with Vitest, including validation, access control, and custom components.
globs: **/*.test.ts, **/*.test.tsx, vitest.config.ts
alwaysApply: false
---

# Sanity Studio Testing Rules

Tests are executable specifications that document business logic and protect content quality.

## 1. Setup (Vitest)

### A. Monorepo Configuration
```typescript
// vitest.config.ts (root)
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: ['apps/*'], // Discover test configs in all apps
  },
})
```

```typescript
// apps/studio/vitest.config.ts
import { defineProject } from 'vitest/config'

export default defineProject({
  test: {
    name: 'studio',
    include: ['**/*.test.ts'],
    environment: 'node',
  },
})
```

### B. Standalone Studio
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    include: ['**/*.test.ts', '**/*.test.tsx'],
    environment: 'node', // Use 'jsdom' for React component tests
  },
})
```

### C. Package Scripts
```json
{
  "scripts": {
    "test": "vitest",
    "test:run": "vitest run"
  }
}
```

---

## 2. What to Test

| Priority | What | Why |
| :------- | :--- | :-- |
| **High** | Validation functions | Protect data integrity |
| **High** | Access control logic | Enforce permissions |
| **High** | Data transformations | Shape content correctly |
| **Medium** | Custom input components | Complex UI behavior |
| **Medium** | Schema helpers | Logic-heavy utilities |
| **Low** | Simple schema definitions | No logic to test |
| **Low** | Thin wrappers | Just pass-through |

---

## 3. Testing Pure Functions (Validation, Access Control)

Pure functions are the easiest to test‚Äîno mocks, no setup.

```typescript
// helpers.ts
import type { CurrentUser } from 'sanity'

export function canEditSlug(user?: Omit<CurrentUser, 'role'> | null): boolean {
  return user?.roles.some((role) => role.name === 'administrator') ?? false
}
```

```typescript
// helpers.test.ts
import { describe, it, expect } from 'vitest'
import type { CurrentUser } from 'sanity'
import { canEditSlug } from './helpers'

describe('canEditSlug', () => {
  it('allows administrators to edit slugs', () => {
    const adminUser: Omit<CurrentUser, 'role'> = {
      id: 'admin-user',
      name: 'Admin',
      email: 'admin@example.com',
      roles: [{ name: 'administrator', title: 'Administrator' }],
    }
    expect(canEditSlug(adminUser)).toBe(true)
  })

  it('prevents non-admin users from editing slugs', () => {
    const editor: Omit<CurrentUser, 'role'> = {
      id: 'editor',
      name: 'Editor',
      email: 'editor@example.com',
      roles: [{ name: 'editor', title: 'Editor' }],
    }
    expect(canEditSlug(editor)).toBe(false)
  })

  it('prevents access when user is null', () => {
    expect(canEditSlug(null)).toBe(false)
  })
})
```

---

## 4. Testing Stateful Logic (Mocking)

For validation that queries the Content Lake, mock the Sanity client.

### A. Mock Client Fixture
```typescript
// __tests__/fixtures/client.ts
import { test as base, vi, type Mock } from 'vitest'
import type { SanityClient } from 'sanity'

type MockSanityClient = SanityClient & { fetch: Mock }

export function createMockClient(): MockSanityClient {
  return { fetch: vi.fn() } as unknown as MockSanityClient
}

export const test = base.extend<{ mockClient: MockSanityClient }>({
  async mockClient({}, use) {
    await use(createMockClient())
  },
})
```

### B. Testing Async Validation
```typescript
// validation.test.ts
import { describe, expect } from 'vitest'
import { test } from './__tests__/fixtures/client'
import { isSingleFeaturedEvent } from './validation'

describe('isSingleFeaturedEvent', () => {
  const createContext = (documentId: string, client: any) => ({
    getClient: () => client,
    document: { _id: documentId, _type: 'event' },
  })

  test('returns true when no other featured event exists', async ({ mockClient }) => {
    mockClient.fetch.mockResolvedValue(false) // No existing featured
    const context = createContext('event-1', mockClient)
    expect(await isSingleFeaturedEvent(true, context)).toBe(true)
  })

  test('returns false when another event is already featured', async ({ mockClient }) => {
    mockClient.fetch.mockResolvedValue(true) // Another event is featured
    const context = createContext('event-2', mockClient)
    expect(await isSingleFeaturedEvent(true, context)).toBe(false)
  })
})
```

---

## 5. Test Organization

```
apps/studio/
‚îú‚îÄ‚îÄ schemaTypes/
‚îÇ   ‚îú‚îÄ‚îÄ validation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ eventValidation.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eventValidation.test.ts  # Co-located
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ DoorsOpenInput.tsx
‚îÇ       ‚îî‚îÄ‚îÄ DoorsOpenInput.test.tsx  # Co-located
‚îî‚îÄ‚îÄ __tests__/
    ‚îî‚îÄ‚îÄ fixtures/
        ‚îú‚îÄ‚îÄ client.ts                # Shared mock client
        ‚îî‚îÄ‚îÄ providers.tsx            # Shared React providers
```

**Rules:**
- Co-locate tests with code (`feature.test.ts` next to `feature.ts`)
- Share fixtures in `__tests__/fixtures/`
- Name tests after the file they verify

---

## 6. Test Quality

### A. One Assertion Per Test
```typescript
// ‚ùå Multiple concerns
it('handles everything', async () => {
  expect(await validate(a)).toBe(true)
  expect(await validate(b)).toBe(false)
})

// ‚úÖ Focused tests
it('allows venue for in-person events', async () => {
  expect(await validate(inPersonEvent)).toBe(true)
})

it('rejects venue for virtual events', async () => {
  expect(await validate(virtualEvent)).toBe(false)
})
```

### B. Descriptive Names
```typescript
// ‚ùå Vague
it('works', () => {})

// ‚úÖ Clear intent
it('calculates doors open time 60 minutes before event', () => {})
```

---

## 7. CI Integration (GitHub Actions)

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'
      - run: pnpm install
      - run: pnpm test:run
```

---

## 8. Boundaries

- ‚úÖ **Always test:** Validation functions, access control, data transformations.
- ‚úÖ **Separate business logic** from validation builders for testability.
- ‚úÖ **Use watch mode** (`pnpm test`) for instant local feedback.
- ‚ö†Ô∏è **Don't test:** Simple schema definitions, third-party libraries, trivial getters.
- üö´ **Never:** Test implementation details over user-facing behavior.
