---
description: Rules for building custom applications with the Sanity App SDK, including React hooks, document handles, real-time patterns, and Suspense best practices.
globs: src/**/*.tsx, src/**/*.ts, sanity.cli.ts, App.tsx
alwaysApply: false
---

# Sanity App SDK Best Practices

## 1. What is the App SDK?

The Sanity App SDK is a toolkit for building **custom React applications** that interact with Sanity content. Unlike Sanity Studio, SDK apps can:
- Work across **multiple projects and datasets**
- Provide **complete UI freedom** (no structured interface)
- Build **custom workflows** tailored to specific needs
- Enable **real-time, multiplayer** content operations

### Key Differences from Studio
| Feature | Sanity Studio | App SDK |
|---------|---------------|---------|
| Projects/Datasets | Single | Multiple |
| UI | Structured | Custom |
| Validation | Built-in | Bring your own |
| Form building | Built-in | Bring your own |

## 2. Project Setup

### Initialize a New App

```bash
# Basic quickstart
npx sanity@latest init --template app-quickstart --organization <your-org-id> --output-path . --typescript --skip-mcp

# With Sanity UI components
npx sanity@latest init --template app-sanity-ui --organization <your-org-id> --output-path . --typescript --skip-mcp
```

### CLI Configuration (`sanity.cli.ts`)

```typescript
import { defineCliConfig } from 'sanity/cli'

export default defineCliConfig({
  app: {
    organizationId: 'your-org-id',
    entry: './src/App.tsx',
  },
  deployment: {
    appId: 'your-app-id', // Added after first deploy
  },
})
```

### App Configuration (`src/App.tsx`)

```typescript
import { SanityApp, type SanityConfig } from '@sanity/sdk-react'

export default function App() {
  // Apps can connect to multiple projects/datasets
  const config: SanityConfig[] = [
    {
      projectId: 'your-project-id',
      dataset: 'production',
    },
    // Add more projects as needed
  ]

  return (
    <SanityApp config={config} fallback={<div>Loading...</div>}>
      {/* Your components here */}
    </SanityApp>
  )
}
```

### Environment Variables

Use the `SANITY_APP_` prefix for environment variables:

```bash
SANITY_APP_PROJECT_ID=abc123
SANITY_APP_DATASET=production
```

Access in code: `process.env.SANITY_APP_PROJECT_ID`

## 3. Document Handles

Document Handles are **lightweight references** to documents, containing only metadata needed to identify them.

```typescript
interface DocumentHandle {
  documentId: string
  documentType: string
  projectId?: string  // Optional - for multi-project apps
  dataset?: string    // Optional - for multi-dataset apps
}
```

### Why Use Document Handles?
- **Performance**: Fetch handles first, then load content as needed
- **Flexibility**: Pass to specialized hooks for specific data
- **Stable Keys**: Use `documentId` as React `key` for lists

### Creating Handles

```typescript
// Option 1: From useDocuments hook (preferred)
const { data: handles } = useDocuments({ documentType: 'article' })

// Option 2: Manual creation with helper (best for TypeGen)
import { createDocumentHandle } from '@sanity/sdk'

const handle = createDocumentHandle({
  documentId: 'my-doc-id',
  documentType: 'article',
})

// Option 3: Manual with `as const` (for TypeGen)
const handle = {
  documentId: 'my-doc-id',
  documentType: 'article',
} as const
```

## 4. Data Fetching Patterns

### Core Philosophy: Prefer Handles Over Raw Queries

```typescript
// ❌ Avoid: Over-fetching with raw GROQ
const { data } = useQuery(`*[_type == "article"]`)

// ✅ Preferred: Fetch handles, then project content
const { data: articles } = useDocuments({ documentType: 'article' })
```

### Hook Selection Guide

| Hook | Use Case | Returns |
|------|----------|---------|
| `useDocuments` | List of documents (infinite scroll) | Document handles |
| `usePaginatedDocuments` | Paginated lists | Document handles |
| `useDocument` | Single document, real-time editing | Full document or field |
| `useDocumentProjection` | Specific fields, display only | Projected data |
| `useQuery` | Complex GROQ queries | Raw query results |

### Fetching Document Lists

```typescript
import { useDocuments } from '@sanity/sdk-react'

function ArticleList() {
  const { data, hasMore, loadMore, isPending } = useDocuments({
    documentType: 'article',
    batchSize: 10,
    orderings: [{ field: '_updatedAt', direction: 'desc' }],
  })

  return (
    <>
      <ul>
        {data.map((handle) => (
          <Suspense key={handle.documentId} fallback={<li>Loading...</li>}>
            <ArticleItem {...handle} />
          </Suspense>
        ))}
      </ul>
      {hasMore && (
        <button onClick={loadMore} disabled={isPending}>
          {isPending ? 'Loading...' : 'Load More'}
        </button>
      )}
    </>
  )
}
```

### Projecting Content from Handles

```typescript
import { useDocumentProjection, type DocumentHandle } from '@sanity/sdk-react'

function ArticleItem(handle: DocumentHandle) {
  const { data } = useDocumentProjection({
    ...handle,
    projection: `{
      title,
      "authorName": author->name,
      "imageUrl": image.asset->url
    }`,
  })

  if (!data) return null

  return (
    <li>
      <h2>{data.title}</h2>
      <p>By {data.authorName}</p>
    </li>
  )
}
```

### Reading Single Documents (Real-time)

```typescript
import { useDocument, type DocumentHandle } from '@sanity/sdk-react'

function ArticleEditor(handle: DocumentHandle) {
  // Full document
  const { data: article } = useDocument(handle)

  // Specific field path
  const { data: title } = useDocument({
    ...handle,
    path: 'title',
  })

  return <div>{title}</div>
}
```

## 5. Document Editing

### Real-time Editing with `useEditDocument`

**Always read from and write to Content Lake** - never use local state for form values.

```typescript
// ❌ Wrong: Local state with submit
function BadTitleForm(handle: DocumentHandle) {
  const [value, setValue] = useState('')
  const editTitle = useEditDocument({ ...handle, path: 'title' })

  function handleSubmit(e: FormEvent) {
    e.preventDefault()
    editTitle(value) // Only writes on submit - causes stale data!
  }

  return (
    <form onSubmit={handleSubmit}>
      <input value={value} onChange={(e) => setValue(e.target.value)} />
      <button type="submit">Save</button>
    </form>
  )
}

// ✅ Correct: Read and write directly to Content Lake
function GoodTitleInput(handle: DocumentHandle) {
  const { data: title } = useDocument({ ...handle, path: 'title' })
  const editTitle = useEditDocument({ ...handle, path: 'title' })

  return (
    <input
      type="text"
      value={title ?? ''}
      onChange={(e) => editTitle(e.currentTarget.value)}
    />
  )
}
```

### Using Functional Updates

```typescript
import { useEditDocument, type DocumentHandle } from '@sanity/sdk-react'

function ArticleEditor(handle: DocumentHandle) {
  const editArticle = useEditDocument(handle)

  const handleTitleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      editArticle((prev) => ({
        ...prev,
        title: e.target.value,
      }))
    },
    [editArticle]
  )

  return <input onChange={handleTitleChange} />
}
```

### Document Actions (Publish, Delete, etc.)

```typescript
import {
  useApplyDocumentActions,
  publishDocument,
  unpublishDocument,
  deleteDocument,
  discardDraftDocument,
} from '@sanity/sdk-react'

function DocumentActions({ handle }: { handle: DocumentHandle }) {
  const apply = useApplyDocumentActions()

  return (
    <div>
      <button onClick={() => apply(publishDocument(handle))}>
        Publish
      </button>
      <button onClick={() => apply(unpublishDocument(handle))}>
        Unpublish
      </button>
      <button onClick={() => apply(deleteDocument(handle))}>
        Delete
      </button>
    </div>
  )
}
```

## 6. Suspense Patterns

The App SDK uses **React Suspense** for data fetching. Master these patterns:

### Wrap Every Data-Fetching Component

```typescript
// ✅ Correct: Suspense around the component using the hook
function ParentComponent() {
  return (
    <Suspense fallback={<LoadingSkeleton />}>
      <DataFetchingComponent />
    </Suspense>
  )
}
```

### One Suspenseful Hook Per Component

```typescript
// ❌ Wrong: Multiple fetchers cause unnecessary re-renders
function BadComponent() {
  const { data: events } = useDocuments({ documentType: 'event' })
  const { data: venues } = useDocuments({ documentType: 'venue' })
  // Both will trigger Suspense together
}

// ✅ Correct: Separate into individual components
function EventsAndVenues() {
  return (
    <>
      <Suspense fallback="Loading events...">
        <EventsList />
      </Suspense>
      <Suspense fallback="Loading venues...">
        <VenuesList />
      </Suspense>
    </>
  )
}

function EventsList() {
  const { data } = useDocuments({ documentType: 'event' })
  return <List items={data} />
}

function VenuesList() {
  const { data } = useDocuments({ documentType: 'venue' })
  return <List items={data} />
}
```

### Prevent Layout Shift with Skeleton Fallbacks

```typescript
const BUTTON_TEXT = 'Open in Studio'

export function OpenInStudio({ handle }: { handle: DocumentHandle }) {
  return (
    <Suspense fallback={<OpenInStudioFallback />}>
      <OpenInStudioButton handle={handle} />
    </Suspense>
  )
}

// Fallback matches final component dimensions
function OpenInStudioFallback() {
  return <Button text={BUTTON_TEXT} disabled />
}

function OpenInStudioButton({ handle }: { handle: DocumentHandle }) {
  const { navigateToStudioDocument } = useNavigateToStudioDocument(handle)
  return <Button onClick={navigateToStudioDocument} text={BUTTON_TEXT} />
}
```

## 7. Event Handling

### Subscribe to Document Events

```typescript
import { useDocumentEvent, DocumentEvent } from '@sanity/sdk-react'

function DocumentWatcher(handle: DocumentHandle) {
  const [notifications, setNotifications] = useState<string[]>([])

  useDocumentEvent({
    ...handle,
    onEvent: (event) => {
      switch (event.type) {
        case DocumentEvent.DocumentEditedEvent:
          setNotifications((prev) => [`Edited: ${event.documentId}`, ...prev])
          break
        case DocumentEvent.DocumentPublishedEvent:
          setNotifications((prev) => [`Published: ${event.documentId}`, ...prev])
          break
        case DocumentEvent.DocumentDeletedEvent:
          setNotifications((prev) => [`Deleted: ${event.documentId}`, ...prev])
          break
      }
    },
  })

  return (
    <ul>
      {notifications.map((msg, i) => (
        <li key={i}>{msg}</li>
      ))}
    </ul>
  )
}
```

## 8. Using Sanity UI

### Installation

```bash
npm install @sanity/ui styled-components
```

### Setup with App SDK

```typescript
import { SanityApp, type SanityConfig } from '@sanity/sdk-react'
import { ThemeProvider } from '@sanity/ui'
import { buildTheme } from '@sanity/ui/theme'

const theme = buildTheme()

export default function App() {
  const config: SanityConfig[] = [
    { projectId: 'your-project-id', dataset: 'production' },
  ]

  return (
    <ThemeProvider theme={theme}>
      <SanityApp config={config} fallback={<div>Loading...</div>}>
        <YourComponents />
      </SanityApp>
    </ThemeProvider>
  )
}
```

### Optional: Faster Styled Components

```bash
# React 18
npm add --save-exact styled-components@npm:@sanity/styled-components

# React 19
npm add --save-exact styled-components@npm:@sanity/css-in-js
```

## 9. TypeScript & TypeGen

Use `createDocumentHandle` or `as const` for proper type inference with Sanity TypeGen:

```typescript
import { createDocumentHandle } from '@sanity/sdk'

// Option 1: Helper function (recommended)
const handle = createDocumentHandle({
  documentId: 'my-doc',
  documentType: 'article', // TypeGen will infer this literal type
})

// Option 2: as const
const handle = {
  documentId: 'my-doc',
  documentType: 'article',
} as const
```

## 10. Development & Deployment

### Development

```bash
npm run dev
# Opens at: https://sanity.io/@your-org-id?dev=http://localhost:3333
```

> **Note:** Safari may have issues during development due to mixed content handling. Use Chrome or Firefox for development.

### Deployment

```bash
npx sanity@latest deploy
```

## 11. Common Patterns

### Multi-Project/Dataset Apps

```typescript
const config: SanityConfig[] = [
  { projectId: 'project-1', dataset: 'production' },
  { projectId: 'project-2', dataset: 'staging' },
]

// Document handles include project/dataset info
const handle: DocumentHandle = {
  documentId: 'doc-123',
  documentType: 'article',
  projectId: 'project-1',
  dataset: 'production',
}
```

### Optimistic Updates

The SDK handles optimistic updates automatically when using `useDocument` + `useEditDocument`:

```typescript
function OptimisticEditor(handle: DocumentHandle) {
  // `data` reflects local optimistic state immediately
  const { data: title } = useDocument({ ...handle, path: 'title' })
  const editTitle = useEditDocument({ ...handle, path: 'title' })

  // Changes appear instantly, sync to Content Lake in background
  return (
    <input
      value={title ?? ''}
      onChange={(e) => editTitle(e.currentTarget.value)}
    />
  )
}
```

### Ref-Based Lazy Loading

Use refs to defer content loading until elements are visible:

```typescript
function LazyContent(handle: DocumentHandle) {
  const ref = useRef(null)

  const { data } = useDocumentProjection({
    ...handle,
    ref, // Content only loads when element is in viewport
    projection: '{ title, body }',
  })

  return <div ref={ref}>{data?.title}</div>
}
```

## 12. Requirements & Limitations

### Requirements
- React v19 or higher
- Node.js v20 or higher

### What's NOT Included
- UI components (use Sanity UI or your own)
- Router
- Form validation
- Schema validation

### Limitations
- Safari development issues (use Chrome/Firefox during development)
- Studio mode only works with project-level endpoints
